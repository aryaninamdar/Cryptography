# -*- coding: utf-8 -*-
"""Aryan Inamdar - Ciphers Project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ia2FLF2Prx7phaz_XcjknfVwMT4PWs0F
"""

import sys
import random

# ------ ENCRYPTION ------

# Atbash Cipher: Takes each letter from original word and replaces it with the letter in a flipped list of the alphabet that corresponds to the original letter's position in the original alphabet list
def Atbash_Cipher():
  print("ATBASH CIPHER")
  # original alphabet list
  alphabet_list = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
  # reversed alphabet list
  reversed_alphabet_list = []
  for x in reversed(alphabet_list):
    # append letters in reverse order to new reversed list
    reversed_alphabet_list.append(x)

  # take input from the user
  word = input("Enter a word/phrase to be encrypted with the Atbash Cipher: ")
  # iterate through every letter in the word
  encrypted_word_list = []
  for letter in word:
    # if there is a space
    if (letter == " "):
      # append space to new word list
      encrypted_word_list.append(" ")
    # if lowercase version of letter is present in the alphabet_list
    if (letter.lower() in alphabet_list):
      # assign the index of the lowercase version of the letter in the list to a variable called letter_index
      letter_index = alphabet_list.index(letter.lower())
      # create variable corresponding_letter which equals the letter in the reversed_alphabet_list which has the same index as the original letter in the original list
      corresponding_letter = reversed_alphabet_list[letter_index]
      # if letter is uppercase
      if (letter.isupper() == True):
        # append the uppercase leter to list by using .upper()
        encrypted_word_list.append(corresponding_letter.upper())
      else:
        # append lowercase letter
        encrypted_word_list.append(corresponding_letter)

  # convert the new word list into a string
  encrypted_word = ''.join([str(elem) for elem in encrypted_word_list])
  # handle exception of no inoput or integer input
  if (encrypted_word == ""):
    print("No valid encryption can be formed")
  else:
    print("The encrypted word/phrase is: ")
    print(encrypted_word)



# Caesar Cipher: Takes each letter from original word and replaces it with the letter in the same list that is shifted from the original position by a certain amount (key)
def Caesar_Cipher():
  print("\n\nCAESAR CIPHER")
  # take inputted key from user
  key = int(input("Insert the key number for the Caesar Cipher: "))
  # original alphabet list
  alphabet_list = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
  # alphabet list which will be shifted... shift list by a certain key
  shifted_alphabet_list = []
  # for each character/element in the alphabet list
  for char in alphabet_list:
    # variable index = the index of the element
    index = alphabet_list.index(char)
    # if the index is less than max index-key
    if (index <= (len(alphabet_list) - 1) - key):
      #  append letter shifted right by key
      shifted_alphabet_list.append(alphabet_list[index+key])
    else:
      # this is done to handle the letters that when shifted will yield an error. The error will be an out of range error.
      # for example, if we try to shift the letter x by 3 units, the new index will be out of range
      # this algorithm subtracts the length of the list from the new index to brring it back in range 
      shifted_alphabet_list.append(alphabet_list[(index+key) - len(alphabet_list)])

  # take input from the user
  word = input("Enter a word/phrase to be encrypted with the Caesar Cipher: ")
  # iterate through every letter in the word
  encrypted_word_list = []
  for letter in word:
    # if there is a space
    if (letter == " "):
      # append space to new word list
      encrypted_word_list.append(" ")
    # if lowercase version of letter is present in the alphabet_list
    if (letter.lower() in alphabet_list):
      # assign the index of the lowercase version of the letter in the list to a variable called letter_index
      letter_index = alphabet_list.index(letter.lower())
      # create variable corresponding_letter which equals the letter in the reversed_alphabet_list which has the same index as the original letter in the original list
      corresponding_letter = shifted_alphabet_list[letter_index]
      # if letter is uppercase
      if (letter.isupper() == True):
        # append the uppercase leter to list by using .upper()
        encrypted_word_list.append(corresponding_letter.upper())
      else:
        # append lowercase letter
        encrypted_word_list.append(corresponding_letter)

  # convert the new word list into a string
  encrypted_word = ''.join([str(elem) for elem in encrypted_word_list])
  # handle exception of no input or integer input
  if (encrypted_word == ""):
    print("No valid encryption can be formed")
  else:
    print("The encrypted word/phrase is: ")
    print(encrypted_word)



# Baconian Cipher: Takes each letter from original word and replaces it with a sequence of 5 letters... These 5 letters are either a's or b's
def Baconian_Cipher():
  print("\n\nBACONIAN CIPHER")
  # original alphabet list
  alphabet_list = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
  # binary alphabet list
  binary_alphabet_list = ['aaaaa', 'aaaab', 'aaaba', 'aaabb', 'aabaa', 'aabab', 'aabba', 'aabbb', 'abaaa', 'abaab', 'ababa', 'ababb', 'abbaa', 'abbab', 'abbba', 'abbbb', 'baaaa', 'baaab', 'baaba', 'baabb', 'babaa', 'babab', 'babba', 'babbb', 'bbaaa', 'bbaab']
  
  # take input from the user
  word = input("Enter a word/phrase to be encrypted with the Baconian Cipher: ")
  # iterate through every letter in the word
  encrypted_word_list = []
  for letter in word:
    # if there is a space
    if (letter == " "):
      # append space to new word list
      encrypted_word_list.append(" ")
    # if lowercase version of letter is present in the alphabet_list
    if (letter.lower() in alphabet_list):
      # assign the index of the lowercase version of the letter in the list to a variable called letter_index
      letter_index = alphabet_list.index(letter.lower())
      # create variable corresponding_letter which equals the letter in the reversed_alphabet_list which has the same index as the original letter in the original list
      corresponding_letter = binary_alphabet_list[letter_index]
      # if letter is uppercase
      if (letter.isupper() == True):
        # append the uppercase leter to list by using .upper()
        encrypted_word_list.append(corresponding_letter.upper())
      else:
        # append lowercase letter
        encrypted_word_list.append(corresponding_letter)

  # convert the new word list into a string
  encrypted_word = ''.join([str(elem) for elem in encrypted_word_list])
  # handle exception of no inoput or integer input
  if (encrypted_word == ""):
    print("No valid encryption can be formed")
  else:
    print("The encrypted word/phrase is: ")
    print(encrypted_word)



# Columnar Transposition Cipher: Takes in a key word input and then the inputted word's letters are arranged in collumns, each collumn represention one of the key word's letters. 
# Then the keyword's letters are put in alphabetical order, and the new encrypted message is read from collumn to collumn.
def Columnar_Transposition_Cipher():
  print("\n\nCOLUMNAR TRANSPOSITION CIPHER")
  # get key word from user
  key_word = input("Enter the key word the Columnar Transposition Cipher: ")
  # put all of its letters into a list
  key_word_list = []
  for letter in key_word:
    key_word_list.append(letter)

  # detect no key word input
  if (key_word_list == []):
    sys.exit("No valid encryption can be formed")

  # get word from user
  word = input("Enter a word/phrase to be encrypted with the Columnar Transposition Cipher: ")
  # put all of its letters in a list
  word_list = []
  for letter in word:
    word_list.append(letter)
    # remove all spaces from the word list
    if (letter == " "):
        word_list.remove(letter)
  
  # detect no word input
  if (word_list == []):
    print("No valid encryption can be formed")

  # split word list into separate rows, each row being the length of the key word
  rows = []
  x = 0
  y = len(word_list)
  for i in range(x,y,len(key_word_list)):
    # append each row to the encrypted word list
    x = i
    row = word_list[x:x+len(key_word_list)]
    # sort each row by using the optimal alphabetically organized key word list as a reference
    sorted_row = [x for _,x in sorted(zip(key_word_list,row))]
    # fill each unfilled row with leading spaces
    if(len(sorted_row) < 5):
      for i in range(5 - len(sorted_row)):
        sorted_row.append('')
    rows.append(sorted_row)
    
  # zip the rows (each row nested within) to form a collumn
  collumns = []
  collumn = list(zip(*rows)) # work on this
  collumns.append(collumn)
  
  # encrypted word list is the final list containing the encryption
  encrypted_word_list = []
  encrypted_word_list = ''.join([str(elem) for elem in collumns])
  # convert the encrypted word list into one string
  encrypted_word = ''.join((filter(lambda x: x not in ['[', ']', '(', ')', ',', "'", "'", " "], encrypted_word_list)))
  # detect is encrypted word is blank
  if (encrypted_word == ""):
    print("No valid encryption can be formed")
  else:
    print("The encrypted word/phrase is: ")
    print(encrypted_word)


# Four Square Cipher: consists of 4 5 by 5 squares. Two of these squares are plaintext with letters a-z (excluding q and in alphabetical order) in this 5 by 5 orientation. 
# The other two squares are ciphertext squares with letters a-z (excluding q and in random order) in this 5 by 5 orientation. 
# The original word is split up into groups of two letters and then, the corresponding letters from the ciphertext squares in the same row and collun relpcae the original letters to form the encryption
def Four_Square_Cipher():
  print("\n\nFOUR SQUARE CIPHER")
  # create 2 plaintext squares
  top_left = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
  bottom_right = top_left[:]
  # create 2 ciphertext squares
  top_right = top_left[:]
  random.shuffle(top_right)
  bottom_left = top_left[:]
  random.shuffle(bottom_left)

  # assign rows and collumns to each letter in each list by creating a list of the coordinates
  top_left_rows_and_collumns = []
  top_right_rows_and_collumns = []
  bottom_left_rows_and_collumns = []
  bottom_right_rows_and_collumns = []

  # top left
  row = 1
  position = 0
  collumn = 0
  for char in top_left:
    # assign collumns
    collumn += 1
    if (collumn == 6):
      collumn = 1
    # assign rows
    position += 1
    if (position == 6):
      row += 1
      position = 1
    # append row and column to coordinates list
    top_left_rows_and_collumns.append(row)
    top_left_rows_and_collumns.append(collumn)

  # top right
  row = 1
  position = 0
  for char in top_right:
    # assign collumns
    collumn += 1
    if (collumn == 11):
      collumn = 6
    # assign rows
    position += 1
    if (position == 6):
      row += 1
      position = 1
    # append row and column to coordinates list
    top_right_rows_and_collumns.append(row)
    top_right_rows_and_collumns.append(collumn)

  # bottom left
  collumn = 0
  for char in bottom_left:
    # assign collumns
    collumn += 1
    if (collumn == 6):
      collumn = 1
    # assign rows
    position += 1
    if (position == 6):
      row += 1
      position = 1
    # append row and column to coordinates list
    bottom_left_rows_and_collumns.append(row)
    bottom_left_rows_and_collumns.append(collumn)

  # bottom right
  row = 5
  for char in bottom_right:
    # assign collumns
    collumn += 1
    if (collumn == 11):
      collumn = 6
    # assign rows
    position += 1
    if (position == 6):
      row += 1
      position = 1
    # append row and column to coordinates list
    bottom_right_rows_and_collumns.append(row)
    bottom_right_rows_and_collumns.append(collumn)

  # convert the rows and collumns lists into nested ones to resemble coordinates
  top_left_coordinates_list = [top_left_rows_and_collumns[i:i+2] for i in range(0, len(top_left_rows_and_collumns), 2)]
  top_right_coordinates_list = [top_right_rows_and_collumns[i:i+2] for i in range(0, len(top_right_rows_and_collumns), 2)]
  bottom_left_coordinates_list = [bottom_left_rows_and_collumns[i:i+2] for i in range(0, len(bottom_left_rows_and_collumns), 2)]
  bottom_right_coordinates_list = [bottom_right_rows_and_collumns[i:i+2] for i in range(0, len(bottom_right_rows_and_collumns), 2)]

  # get word from user
  word = input("Enter a word/phrase to be encrypted with the Four Square Cipher: ")

  # add letters from word to new word list
  # remove spaces and detect int input
  word_list = []
  for letter in word:
    word_list.append(letter.lower())
    if (letter == " "):
        word_list.remove(letter)
    elif (type(letter) == int):
      sys.exit("No valid encryption can be formed")
    # i/j
    elif (letter == "j" or letter == "J"):
      word_list.remove(letter)
      word_list.append("i")

  # if word length is odd, add random letter to the end to make the encryption accurate
  if (len(word_list) % 2 != 0):
    word_list.append("x")
  
  # replace letters of original word with letters in coreesonding row/column
  encrypted_word_list = []
  for letter1, letter2 in zip(word_list[0::2], word_list[1::2]):
    # find index of each letter in the plaintext word lists 
    letter1_index = top_left.index(letter1)
    letter2_index = bottom_right.index(letter2)
    # find row and column of letter1
    letter1_corresponding_coordinates = top_left_coordinates_list[letter1_index]
    letter1_row = letter1_corresponding_coordinates[0]
    letter1_collumn = letter1_corresponding_coordinates[1]
    # find row and column of letter1
    letter2_corresponding_coordinates = bottom_right_coordinates_list[letter2_index]
    letter2_row = letter2_corresponding_coordinates[0]
    letter2_collumn = letter2_corresponding_coordinates[1]
    # replace letter1 (top right)
    new_letter1_row = letter1_row
    new_letter1_collumn = letter2_collumn
    new_letter1_index = top_right_coordinates_list.index([new_letter1_row, new_letter1_collumn])
    new_letter1 = top_right[new_letter1_index]
    encrypted_word_list.append(new_letter1)
    # replace letter2 (bottom_left)
    new_letter2_row = letter2_row
    new_letter2_collumn = letter1_collumn
    new_letter2_index = bottom_left_coordinates_list.index([new_letter2_row, new_letter2_collumn])
    new_letter2 = bottom_left[new_letter2_index]
    encrypted_word_list.append(new_letter2)

  # convert the encrypted word list into a string and display the random keys
  random_key1 = ''.join([str(elem) for elem in top_right])
  random_key2 = ''.join([str(elem) for elem in bottom_left])
  print("Random Key 1: ", random_key1)
  print("Random Key 2: ", random_key2)
  encrypted_word = ''.join([str(elem) for elem in encrypted_word_list])
  print("The encrypted word/phrase is: ")
  print(encrypted_word)


# ------ DECRYPTION ------

def Atbash_Cipher_Decryption():
  print("\n\nATBASH CIPHER DECRYPTION")
  # original alphabet list
  alphabet_list = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"]
  # reversed alphabet list
  reversed_alphabet_list = []
  for x in reversed(alphabet_list):
    # append letters in reverse order to new reversed list
    reversed_alphabet_list.append(x)

  # take input from the user
  word = input("Enter an encrypted word/phrase to be decrypted with the Atbash Cipher: ")
  # iterate through every letter in the word
  decrypted_word_list = []
  for letter in word:
    # if there is a space
    if (letter == " "):
      # append space to new word list
      encrypted_word_list.append(" ")
    # if lowercase version of letter is present in the alphabet_list
    if (letter.lower() in alphabet_list):
      # assign the index of the lowercase version of the letter in the list to a variable called letter_index
      letter_index = alphabet_list.index(letter.lower())
      # create variable corresponding_letter which equals the letter in the reversed_alphabet_list which has the same index as the original letter in the original list
      corresponding_letter = reversed_alphabet_list[letter_index]
      # if letter is uppercase
      if (letter.isupper() == True):
        # append the uppercase leter to list by using .upper()
        decrypted_word_list.append(corresponding_letter.upper())
      else:
        # append lowercase letter
        decrypted_word_list.append(corresponding_letter)

  # convert the new word list into a string
  decrypted_word = ''.join([str(elem) for elem in decrypted_word_list])
  # handle exception of no input or integer input
  if (decrypted_word == ""):
    print("No valid encryption can be formed")
  else:
    print("The encrypted word/phrase is: ")
    print(decrypted_word)


Atbash_Cipher()
Caesar_Cipher()
Baconian_Cipher()
Columnar_Transposition_Cipher()
Four_Square_Cipher()
Atbash_Cipher_Decryption()